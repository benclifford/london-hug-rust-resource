<html>
        <head>
                <link rel="stylesheet" href="reveal.js/css/reveal.css">
                <link rel="stylesheet" href="reveal.js/css/theme/black.css">
                <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
<title>Ownership in the type system / London Haskell / June 2018</title>
        </head>
        <body>
  <div class="reveal">
    <div class="slides">
      <section><h1>Ownership in the type system</h1>
<p>Ben Clifford</p>
<p>London Haskell, June 2018</p>
<p><a href="mailto:benc@hawaga.org.uk">benc@hawaga.org.uk</a></p>
<p>Press 's' for speaker notes</p>

<aside class="notes">
0. Rust can provide memory safety by statically tracking who owns
each piece of allocated memory.  This needs more elaborate type
signatures, and plenty of wrestling to make it all compile -
something any Haskeller will be familiar with.  I'll talk a bit
about the theory, a bit about the concrete language features
that make this more usable, and a bit about some vaguely related
Haskell.  
</aside>

      </section>


<section>
<h2>What is rust?</h2>
<ul>
<li> closures
<li> traits / typeclasses
<li> parameterised types
<li> concurrency
<li> pattern matching
<li> single-assignment variables
<li> nice macros
</ul>

<aside class="notes">
1. I'm going to talk about resource management in a language called
Rust, which I expect a lot of people have heard about, even if
they haven't used it.

I'm going to mix up three languages in the code examples:
Haskell (because, of course), C (because it has different
examples from Haskell), and of course Rust.

Briefly, Rust is a "safe, concurrent, practical language". What I think
is interesting is that they care about safety, but have a strong
emphasis on performance and are trying to be a competitor in the
same space as C.

The most notable use is that 
parts of the Firefox web browser are written in Rust.

It's got plenty of modern language features - here's a list - but
this isn't a Rust intro talk so I'm not really going to talk about them
except when needed.
</aside>
</section>

<section>
<pre><code class="C" data-trim data-noescape>
void f() {
  r = malloc(10);
  mutate(r);
  free(r);
}
</code></pre>

<pre><code class="haskell" data-trim data-noescape>
do
  r <- hOpenFile "foo" WriteMode
  hPutStrLn r "hello world"
  hClose r 
</code></pre>
<aside class="notes">
2. resource management techniques - a review

First I'll briefly review some resource management techniques -
by resource I'm using memory as my main example, but there are
other examples such as open files; by "management", i mean
keeping track of how that resource is allocated, used and released.

2.1 There's an explicit, C-like, style.

(see slide)
We allocate some memory (for example, with malloc). We use it
(I don't care how, for the purposes of this talk).
We free it. Here I'm using r to mean a "reference" or a "pointer"
without getting too technical about what one of those is.

Or we open a file, write to it, and close it - the reference there
is the file handle.

In these two examples, that happens all in a row in the source code,
so it's quite easy to reason about.

In reality it is likely a reference gets passed around
stored and used in several different places,
on its eventual journey to being released.

(As a side note, C is pretty liberal about what you can
use that memory for - you can allocate a number of bytes without
really telling the compiler what you're going to use those bytes
for.)

The correctness proof happens "in our head (or test suites etc)",
not in the compiler.

</aside>
</section>

<section>
<h2>use-after-free</h2>

<pre><code class="C" data-trim data-noescape>
void f() {
  r = malloc(10);
  free(r);
  mutate(r);
}
</code></pre>

<pre><code class="haskell" data-trim data-noescape>
do
  r <- hOpenFile "foo" WriteMode
  hClose r 
  hPutStrLn r "hello world"
</code></pre>

<aside class="notes">
What might go wrong?

We might free the resource before we have finished using it. Then what
happens? Memory corruption or a segfault or other failures.
[use-after-free]
</aside>

</section>

<section>
<h2>resource leak</h2>
<pre><code class="C" data-trim data-noescape>
void f() {
  r = malloc(10);
  mutate(r);
}
</code></pre>

<pre><code class="haskell" data-trim data-noescape>
do
  r <- hOpenFile "foo" WriteMode
  hPutStrLn r "hello world"
</code></pre>

<aside class="notes">

We might forget to free the memory, and then we have a memory leak:
that memory remains allocated "forever" (for some notion of forever)

</aside>

</section>

<section>

<pre><code class="haskell" data-trim data-noescape>
let r = FooConstructor
    in process r
</code></pre>

<aside class="notes">
2.2 Another style of resource management is to use garbage collection.

This has been round since the 1950s, though I first really used this in
Java. It's pretty much the standard approach for memory
management in high level
languages - for example, it is how Haskell does things - but not other
stuff like file handle management.

So how does this work?
We allocate some memory. We use it. We just stop talking about it
and it goes away. Eventually.

An advantage here is that if 'r' is in scope,
we know the memory will not have been released.

We can't name a thing, unless that thing is valid: knowing the "name"
of the thing keeps it valid.

A disadvantage is that garbage collectors run at runtime - this adds on
a bunch of runtime overhead. Namecheck pusher/will for their
especially degenerate garbage collection situation they encountered.

Another disadvantage is that sometimes we do want to be a
bit more explicit about when 
a resource is released - we want to know a file has been closed,
perhaps - but with garbage collection, you have to "hope" that you
really have got rid of all references and that the collector runs
"in time".

By "hope" I mean manually prove outside of the type system.
</aside>

</section>

<section>
<pre><code class="haskell" data-trim data-noescape>
withFile "myfile.txt" WriteMode $
  \r -> hPutStrLn r "hello world"
</code></pre>

<pre><code class="C" data-trim data-noescape>
void f()
{
  int x;
  mutate(&x)
}
</code></pre>
<aside class="notes">
A third way is scope based, local variables: built into C, and
provided by bracketing style of helper function for files in 
Haskell.

The resource is released when the scope ends: in the C example,
the space usually happens to be on the stack and disappears when
we return from the function; in the Haskell example, we have this
helper which opens a file, passes the handle, and then closes
the file at the end - so the handle is valid within this
scope defined by the lambda expression.
</aside>
</section>

<section>
<pre><code class="haskell" data-trim data-noescape>
do 
  r' <- withFile "myfile.txt" WriteMode $
          \r -> return r
</code></pre>

<pre><code class="C" data-trim data-noescape>
int * f()
{
  int x;
  return &x;
}
</code></pre>



<aside class="notes">
We don't write a free call, and x will always be released, but we
need to be careful to not pass a reference to x outside of the
scope (for example, if mutate stores it in a global struct for
later use) - otherwise we get "use-after-free" bugs like in the
earlier examples.
</aside>
</section>

<section>
<pre><code class="C" data-trim data-noescape>
int f(int *r)
{
  return 7;
}
</code></pre>

<pre><code class="haskell" data-trim data-noescape>
f :: (Handle, Handle) -> IO ()
f (_,b) = hClose b
</code></pre>


<aside class="notes">
3. So let's dig down to some of the basic things you can do with
references/handles/pointers, and how those things can cause trouble
with reasoning. These are things you can do to any value in most
languages, but the problems specifically arise when those values
are references, that is names to some other resource (a pointer to
member, a file handle).

First, we're allowed to forget references. We might just stop
talking about a variable; or we might only pattern match 
part of a tuple.

When we do this, we hope that someone else (either another part
of our code, or a garbage collector) will release the resources.
</aside>

</section>

<section>

<pre><code class="C" data-trim data-noescape>
void f() {
  r = malloc(10);
  mutate(r);
  free(r);
}
</code></pre>

<pre><code class="haskell" data-trim data-noescape>
do
  r <- hOpenFile "foo" WriteMode
  hPutStrLn r "hello world"
  hClose r 
</code></pre>
<aside class="notes">
That's usually combined with being able to duplicate references. We've
passed a reference into <code>mutate</code> or <code>putStrLn</code>
and those have done some stuff and then forgetten the reference,
but that's fine, because we've also kept a copy for ourselves to
use to free/close later.

Those two everyday operations - forgetting and duplicating - are part
of what makes it quite hard to reason about whats going on.

Controlling these inherently dangerous operations
is a big part of Rust's resource management story.
</aside>

</section>


<section>
<pre>
Every value in rust is owned by exactly one variable. When that
variable goes out of scope, that value is freed.

To begin with, that looks like the scope based model I talked about
previously.

[slide]
fn main()
{
  let r = vec![1, 2, 3];
  process(&r);
}

Rust puts in a static implicit free when r goes out of scope.
To be clear - it isn't garbage collected.

It's basically doing this, which is more explicit and also valid rust.

[slide]
fn main()
{ 
  let r = vec![1, 2, 3];
  process(&r);
  drop(r);
}

OK, so here's some buggy code. It's got a use-after-free bug that
I hope is obvious - we've release r and then attempted to use it.

Rust rejects this! There error says on line 6 we tried to use a value,
but something had happened at line 5.

It looks like it is detecting that r has been released, and giving
an error - but that error talks about "moving" which is a more
general concept.

What has happened here is that I've transferred ownership of that
vector - instead of being owned by <code>r</code> in this current
scope, it has been handed over to be owned by drop, and so we can't
also have it owned by r any more. So we have this novelty that
variables can disappear effectively
out of scope by using them in certain ways.

Then it turns out that the implementation of drop just releases
all the resources and can safely forget about te value.

[slide]
fn main()
{
  let r = vec![1, 2, 3];
  process(&r);
  drop(r);
  process(&r);
}

5 |   drop(r);
  |        - value moved here
6 |   process(&r);
  |            ^ value used here after move


===

So why does that happen for drop and not for process? Because we're
passing in a reference to that value, rather than passing the
value itself.

References have slightly different rules applied to them, but there
is still novel checking going on.

Here's more code, with two function calls - it'll output the
vector size twice.

[slide]
fn main()
{
  let r = vec![1, 2, 3];
  process(&r);
  process(&r);
}

fn process(s : &Vec<i32>) {
  println!("vector size: {}", (*s).len());
}

$ ./a 
vector size: 3
vector size: 3

===

What happens if I try to release the vector inside the process
function - trying to introduce a different use-after-free
bug.

As we might hope, we get a compiler error - "cannot move out of
borrowed context". What does that mean? When we call drop, we
transfer ownership of the value to drop. But, inside "process"
we don't actually own s, so it isn't ours to give away.

We've just "borrowed" it from the caller, and part of that calling
contract is that at the end, we have to give it back.
We can't release it;
we can't transfer the ownership to someone else.

We can however allow another function call to borrow it from us, deeper
and deeper: we know statically 
that next level of function will give it back,
because it's only borrowing, and so we know that at the end of
process, we'll be able to give it back.


[slide]
fn main()
{
  let r = vec![1, 2, 3];
  process(&r);
  process(&r);
}

fn process(s : &Vec<i32>) {
  println!("vector size: {}", s.len());
  drop(*s)
}

error[E0507]: cannot move out of borrowed content
  --> a.rs:10:8
   |
10 |   drop(*s)
   |        ^^ cannot move out of borrowed content



====

To clarify that, here's a different implementation that
fails. Instead of "process" borrowing the vector, it takes
ownership of it (which includes responsibility for dropping it).
So now the vector is allocated in main, but ownership is moved
to process, and release at the end of process. We can see statically
that it isn't available to be passed into the second call of process.
If we wanted to, we could return it back as a return value though.

A lot of rust developers talk about "fighting the borrow checker".
This is basically making what I've just shown you work in real world
situations. To me, it feels quite like when you have complex type
signatures in haskell that you're trying to get to type check
and you can sort of see how but it is still a battle.

[slide]
fn main()
{
  let r = vec![1, 2, 3];
  process(r);
  process(r);
}

fn process(s : Vec<i32>) {
  println!("vector size: {}", s.len());
} // release happens here

error[E0382]: use of moved value: `r`
 --> a.rs:5:11
  |
4 |   process(r);
  |           - value moved here
5 |   process(r);
  |           ^ value used here after move
  |
  = note: move occurs because `r` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait

Now, look at this bit of the error message, where it says a move
occurs because the vector type doesn't implement the copy trait.
Traits are like haskell typeclasses, and the copy trait is a marker
that says actually you can safely duplicate this value. If it's a
simple type, such as a 32 bit integer, then the ownership rules
can be more relaxed.

===

so here's the same code, but instead of using a vector, it uses
a single integer. This compiles and run fine because i32 has
the copy trait. So all this borrow checking and ownership
stuff doesn't apply to "simple" values, thankfully. Just to more
complicated values.


[slide]
fn main()
{
  let r = 10;
  process(r);
  process(r);
}

fn process(s : i32) {
  println!("integer is: {}", s);
}

$ ./b 
integer is: 10
integer is: 10

====

Now let's talk about reference lifetimes a bit. here's some code
that given two vectors, returns the longest of the two. I'm passing
in two references, that are each
borrowed from somewhere, and returning one of those references based
on a length test.

This doesn't compile. We've been given two references to vectors,
and we know
those references are valid inside the function because we've borrowed
those values - so we can do things like look at the lengths.

But if we return a reference from a function, how do we know how
long that reference is for? What if I want to return a reference
to a value that goes out of scope at the end of the calling function?

In this code, the l reference is going to be valid as long
as r and q are both alive; but if either of them has been dropped,
then potentially there's a problem and we can't be allowed to
use that reference any more.

[slide]
fn main()
{
  let r = vec![1, 2, 3];
  let q = vec![1, 2, 3, 4];
  let l = longest(&q, &r);
  process(l);
}

fn longest(s : &Vec<i32>, t : &Vec<i32>) -> &Vec<i32> {
  if (*s).len() > (*t).len() {
    return s;
  } else {
    return t;
  }
}

error[E0106]: missing lifetime specifier
 --> c.rs:9:45
  |
9 | fn longest(s : &Vec<i32>, t : &Vec<i32>) -> &Vec<i32> {
  |                                             ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `s` or `t`

====

we can get round this by using lifetime annotations, like this. These
are compile time variables that refer to reference lifetimes.
What we've said is that longest wants to be given some lifetime
a (at compile time), such that 
s and t are references that both valid for at least that long;
and the reference that comes back will also be valid for at least
that long.

In this example, in main, we call longest with an implicit compile
time parameter that refers basically to the scope of main: r and q
are valid in that scope, and so the return value l is valid in that
scope too.

If we called longest somewhere else, there might be a different
implicit scope for that invocation.

[slide]
fn main()
{
  let r = vec![1, 2, 3];
  let q = vec![1, 2, 3, 4];
  let l = longest(&q, &r);
  process(&l);
}

fn longest <'a> (s : &'a Vec<i32>, t : &'a Vec<i32>) -> &'a Vec<i32> {
  if (*s).len() > (*t).len() {
    return s;
  } else {
    return t;
  }
}


====

3.  So what does Rust do?

3.1 Well, none of those.

it lets us write code like this:

SLIDE: TODO: use rust syntax
r = new Foo() 
mutate(r)
// drop(r)

like the garbage collector or local variable case;

... r can be a complex structure

... but with memory release somehow managed
statically - at compile time (like the local variable case)

... but we can pass a pointer to that memory around outside of 
the local scope (like the garbage collected case).

Rust puts in release calls (called Drop) at the right place.

This isn't magic though, and if we squish down complication in one
place, it pops up in another. I'm going to talk about that complication
in the rest of this talk.


--
What if we regard those operations (forgetting, and duplication)
as inherently dangerous, and try to get rid of them?

The only way we can get rid of a pointer is by passing it into free()

SLIDE:
r = alloc()
free(r)

What about if we want to use that memory in a function?

Slide:
r = alloc()
mutate(r)
free(r)

This doesn't work for two reasons:

firstly, mutate() isn't allowed to forget r; and secondly, we can't
pass r to mutate *and* keep a copy for later use.

So mutate() could free r itself, but that's a bit limiting. Another
thing it could do is pass it back:

r = alloc()
r' = mutate(r)
free(r')

mutate(r) = 
   ...
   return r


We end up with explicit threading of the reference through the code.

Then, we can use syntax to hide that, and
get back this: (todo: rust & syntax for passing references - borrowing)

r = alloc()
mutate(r)
free(r)

which looks the same syntactically as our earlier example but now has
linear semantics. We can say that mutate has "borrowed" the value
and given it back afterwards.

Another bit of syntax we can do: instead of needing to expliclty
free r, we can insert a free call implicitly, when r goes out of
scope.

r = alloc()
mutate(r)

Syntactically this looks like the garbage collected case -
but it isn't: we have those linear semantics that means we know r is still
allocated at the end of this code block and that it's going to
go out of scope at the end of this code block and that it has not
been duplicated anywhere; so we can and must release it at the
end of the block. releasing it like a stack automatic, even though
there might be a lot more than just a couple of bytes on the stack.

NOTES:

0. about rust (1 min)

1. Rust details (11 mins)

    - motivation: basic motivation: freeing memory.
         C - explicit frees. reasoning in programmers head.

           - code sample. code sample with double free, or free then re-use. or we might forget to free it at all. memory leak in the sense of "the allocator knows it is allocated, but nobody else does"

         many more recent languages (Java/Python/Haskell/Python...) - garbage collection. expensive. "naive" - as a programmer I know that some data won't be freed "now", but GC still has to make a *runtime* check of all that. Lots of GC tech over the years. It's "impossible" to have a pointer to memory that isn't allocated (and we usually call these references now, not pointers)

           - code sample: allocate. long process, but keep variable assigned. so doesn't get freed. every gc in long process needs to consider this allocation. memory leak in the sense of "we don't need it, but the GC won't release it because we have a variable pointing at it".

       - what if we could have the efficiency of static checking, with
         the safety of GC?
       - rust attempts to give some of this, though of course as you whack the mole down in one place, it pops up somewhere else, as we'll see...

  ownership

  lack of explicit frees - the frees go where the owner drops
   the value

  borrowing so you don't have to pass things back
    - fighting the borrow checker. aka fighting the type checker.

  type signatures - and how they are reminiscent of crazy haskell
    type signatures  (eg lens, eff, servant)

  analogies to compile-time/static garbage collection

  various wrappers for ownership fun (reference counting - with
    standard rc problems)

  passing between threads?
   - somewhat overblown chapter title "Fearless Concurrency" - specifically relevance to memory safety
   - closures - passing ownership into a closure. 'move' keyword (not just for thread stuff... but useful when launching a thread). 'Copy' trait - for things that look like "values" - got rid of duplication but this is how we allow it. talking about "ownership" that is not just hierarchical scopes. channels - sending down a channel changes ownership - no longer in local scope, so we don't (and can't) use a thing or free it. message passing - but without copying.

(concurrent) rust exmaples that are neat:

  example of interesting ownership transfer:
  1. todo: a simple transfer of ownership (into a function? or a struct?)

  2. channel concurrency - sending memory to someone else is, like a free,
    a way of safely getting rid of our responsibility for a resource,
    and also means we can't access it any more.

  mutux-on-memory (in shared memory concurrency section) - uses a smart pointer
   the is aquired by unlocking, and when you drop the smart pointer,
   it re-locks the mutex. mention that you would use unsafe to do this,
   which, like in haskell, declares that you believe it to be safe
   but the compiler can't check so. 'Drop' trait. Combines a value
   which proves that we have access to the locked meory with the
   actual reference to the memory, into a single smart pointer.
   We can only ever have one of these smart pointers in existence at
   once (if mutex is correctly implemented)

 - introduce "smart pointers" before that? as a pointer that can 
    know how its going to be used - mutex as a particular instance
    of that - or perhaps just mutex as *the* example to introduce
    this?
   - because we're more restricted on what we can do with pointers
     /references, we can have (need?) more rust libraries that express
      reference/pointer patterns in rust code,
     that previously existed in our head or in the garbage collector.
    - reference counting smart pointers, mutex above.
      - eg 1. reference counting smart pointer: the pointer owns
         the memory, and keeps track of how many people have a copy,
         (because it has code both to create and drop references),
         and can release memory on 0 references.
      - more interestingly, mutex, for concurrency.


2. what does haskell offer? (7 mins)
- and can point out arnaud in the pub afterwards
 2.1 state monads: (2 min)
    state actions are compoletely serialised even when operating on
    "different" pieces of state (you can name them differently as STRef
    but actions are still explicitly serialised). pretty lame.
    we have (ST s) with an uninstantiated s, to stop us passing
    out a reference to code in a different sequence, or to pure code.
  - something to do with if we want a thing to do linear operations
     on, we can't let it be a pure "value" any more - for example,
     mutable in place array operations? (I think there's an array
     for that - MArray) - linearisation of all array operations by
     monad sequence. - code examples of MArray? - there's an example
     in s2.2 of the linear types paper, even.
 2.2 linear types - tweag proposal (5 min)
    very brief overview
    - similar direction but different: can do more, and less.
      eg rust has sugar - for borrowing (pass a value in and
      get it back, and it is in a particular state inside the
      borrowed call), and for implicitly releasing a value.
    - maybe overview of interesting haskell-specific issues based
        on section titles in paper - eg "consuming" a value in a lazy
          language; using higher order functions; ... and some of the case studies. perhaps just put those on a slide and mention them in hardly any depth?

====
aspiwack [17:42]
Full instructions here: https://github.com/tweag/ghc/tree/linear-types#readme

benc [17:42]
just so i can say in the talk "i have compiled something fairly simple with it" rather than "i have heard about this thing"
aspiwack [17:42]
A library with a fully configured stack.yaml: https://github.com/tweag/linear-base/
====

3. overview slide (1 min)


really care about counting references at compile time:
 given a reference R, do we: drop it, duplicate it, neither (in which case, I think, it is linear?)


rust notion of lifetimes and ownership - these can be awkward to reason about. compile time type variables...


copy trait: can mark that it is meanigful to just copy the bits to
 duplicate a value.
 - for example a double-length integer would make sense, but a
   file handle not so.
 - so this is not really about the "size" of the data, but of who
   is managing any other resources that are references by the
   bitwise value.
  
clone trait: let's the type handle how to duplicate itself, and is
 invoked as an explicit operation.
 

</pre>
</section>
                        </div>
                </div>
                <script src="head.js"></script>
                <script src="reveal.js/js/reveal.js"></script>
                <script>
                        Reveal.initialize({
  transition: "none",
  slideNumber: "c/t",
  dependencies: [
{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                { src: 'reveal.js/plugin/notes/notes.js', async: true },
                { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

                ]
                        });
                </script>
        </body>
</html>


