

<pre>

I'm going to talk about Rust, and specifically the way that Rust does
memory management.

Briefly, Rust is a "safe, concurrent, practical language". What I think
is interesting is that they care about safety, but have a strong
emphasis on performance. The most notable use is that 
parts of the Firefox web browser are written in Rust.

So first I'll briefly review some memory management techniques:

We have C-like:

slide - code example:

r = malloc(10)
mutate(r)
free(r)

We allocate some memory (for example, with malloc). We use it
(I don't care how, for the purposes of this talk).
We free it. Here I'm using r to mean a "reference" or a "pointer"
without getting too far into the definition of what one of those
actually is.

In this example, that happens all in a row, but in
reality it is likely the pointer to the memory gets passed around
and stored in different places, on its eventual journey to being
released. As a side note, C is pretty liberal about what you can
use that memory for - you can allocate a number of bytes without
really telling the compiler what you're going to use those bytes
for.

What might go wrong?

We might free the memory before we have finished using it. Then what
happens? Memory corruption or a segfault.

We might forget to free the memory, and then we have a memory leak:
that memory remains allocated "forever" (for some notion of forever)

and as a side note, we might allocate 4 bytes but run it on code that
expects 8 bytes... similar memory corruption problems.


Another style to use garbage collection. I first really used this in
Java, and it's pretty much the standard approach in high level
languages - for example, it is how Haskell does things.

Slide - example:

r = new Foo()
mutate(r)

We can allocate some memory, we can use it, and then when we're done
we just stop talking about it, and let the garbage collector eventually
tidy things up. As a side note, these languages are often a bit stricter
about the types of references being passed around, but that is somewhat
(but not entirely) orthogonal to memory management.

An advantage here: if 'r' is in scope, we know the memory will not have
been released.

A disadvantage is that garbage collectors run at runtime - this adds on
a bunch of runtime overhead.

So what does Rust do?

it lets us write code like this:

SLIDE: TODO: use rust syntax
r = new Foo() 
mutate(r)

like the garbage collector case; but with memory release somehow managed
statically - at compile time. There's no runtime garbage collector.

This isn't magic though, and if we squish down complication in one
place, it pops up in another. I'm going to talk about that complication
in the rest of this talk.


Let's take a more theoretical look at things that you can do with 
a pointer or a reference (or a handle...) and how that might go
wrong: - actually, these are things you can do to any value in a
language, but the problems happen when those values are references.

We can forget a reference:

SLIDE: todo in rust
f(r) = 7

We had a pointer to r. But we've abandoned it without releasing
the memory.

Often that's OK, because we can also duplicate references:

SLIDE:
f(r) = 7

r = alloc()
f(r)
free(r)

We passed r into f, but we also kept a copy ourselves and used it
to free memory.

A non-reference version of this might be

SLIDE: (on end of previous slide?)
sqr(x) = x * x

where we duplicate the number stored in x - that's usually fine to do
in this case.

What if we regard those operations (forgetting, and duplication)
as inherently dangerous, and try to get rid of them?

The only way we can get rid of a pointer is by passing it into free()

SLIDE:
r = alloc()
free(r)

What about if we want to use that memory in a function?

Slide:
r = alloc()
mutate(r)
free(r)

This doesn't work for two reasons:

firstly, mutate() isn't allowed to forget r; and secondly, we can't
pass r to mutate *and* keep a copy for later use.

So mutate() could free r itself, but that's a bit limiting. Another
thing it could do is pass it back:

r = alloc()
r' = mutate(r)
free(r')





NOTES:

0. about rust (1 min)

1. Rust details (11 mins)

    - motivation: basic motivation: freeing memory.
         C - explicit frees. reasoning in programmers head.

           - code sample. code sample with double free, or free then re-use. or we might forget to free it at all. memory leak in the sense of "the allocator knows it is allocated, but nobody else does"

         many more recent languages (Java/Python/Haskell/Python...) - garbage collection. expensive. "naive" - as a programmer I know that some data won't be freed "now", but GC still has to make a *runtime* check of all that. Lots of GC tech over the years. It's "impossible" to have a pointer to memory that isn't allocated (and we usually call these references now, not pointers)

           - code sample: allocate. long process, but keep variable assigned. so doesn't get freed. every gc in long process needs to consider this allocation. memory leak in the sense of "we don't need it, but the GC won't release it because we have a variable pointing at it".

       - what if we could have the efficiency of static checking, with
         the safety of GC?
       - rust attempts to give some of this, though of course as you whack the mole down in one place, it pops up somewhere else, as we'll see...

  ownership

  lack of explicit frees - the frees go where the owner drops
   the value

  borrowing so you don't have to pass things back
    - fighting the borrow checker. aka fighting the type checker.

  type signatures - and how they are reminiscent of crazy haskell
    type signatures  (eg lens, eff, servant)

  analogies to compile-time/static garbage collection

  various wrappers for ownership fun (reference counting - with
    standard rc problems)

  passing between threads?

2. what does haskell offer? (7 mins)
 2.1 state monads: (2 min)
    state actions are compoletely serialised even when operating on
    "different" pieces of state (you can name them differently as STRef
    but actions are still explicitly serialised)
 2.2 linear types - tweag proposal (5 min)
    very brief overview
    - similar direction but different: can do more, and less.
      eg rust has sugar - for borrowing (pass a value in and
      get it back, and it is in a particular state inside the
      borrowed call), and for implicitly releasing a value.
====
aspiwack [17:42]
Full instructions here: https://github.com/tweag/ghc/tree/linear-types#readme

benc [17:42]
just so i can say in the talk "i have compiled something fairly simple with it" rather than "i have heard about this thing"
aspiwack [17:42]
A library with a fully configured stack.yaml: https://github.com/tweag/linear-base/
====

3. overview slide (1 min)


really care about counting references at compile time:
 given a reference R, do we: drop it, duplicate it, neither (in which case, I think, it is linear?)


rust notion of lifetimes - these can be awkward to reason about. compile time type vairables...

</pre>
