<html>
        <head>
                <link rel="stylesheet" href="reveal.js/css/reveal.css">
                <link rel="stylesheet" href="reveal.js/css/theme/black.css">
                <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
<title>Ownership in the type system / London Haskell / June 2018</title>
        </head>
        <body>
  <div class="reveal">
    <div class="slides">
      <section><h1>Ownership in the type system</h1>
<p>Ben Clifford</p>
<p>London Haskell, June 2018</p>
<p><a href="mailto:benc@hawaga.org.uk">benc@hawaga.org.uk</a></p>
<p>Press 's' for speaker notes</p>

<aside class="notes">
0. Rust can provide memory safety by statically tracking who owns
each piece of allocated memory.  This needs more elaborate type
signatures, and plenty of wrestling to make it all compile -
something any Haskeller will be familiar with.  I'll talk a bit
about the theory, a bit about the concrete language features
that make this more usable, and a bit about some vaguely related
Haskell.  
</aside>

      </section>


<section>
<h2>What is rust?</h2>
<ul>
<li> closures
<li> traits / typeclasses
<li> parameterised types
<li> concurrency
<li> pattern matching
<li> single-assignment variables
</ul>

<aside class="notes">
1. I'm going to talk about resource management in a language called
Rust, which I expect a lot of people have heard about, even if
they haven't used it.

I'm going to mix up three languages in the code examples:
Haskell (because, of course), C (because it has different
examples from Haskell), and of course Rust.

Briefly, Rust is a "safe, concurrent, practical language". What I think
is interesting is that they care about safety, but have a strong
emphasis on performance and are trying to be a competitor in the
same space as C.

The most notable use is that 
parts of the Firefox web browser are written in Rust.

It's got plenty of modern language features - here's a list - but
this isn't a Rust intro talk so I'm not really going to talk about them
except when needed.
</aside>
</section>

<section>
<pre><code class="C" data-trim data-noescape>
void f() {
  r = malloc(10);
  mutate(r);
  free(r);
}
</code></pre>

<pre><code class="haskell" data-trim data-noescape>
do
  r <- hOpenFile "foo" WriteMode
  hPutStrLn r "hello world"
  hClose r 

</code></pre>
<pre><code class="haskell" data-trim data-noescape>
withFile $ \h -> hPutStrLn h "hello world"
</code></pre>

<aside class="notes">
2. resource management techniques - a review

First I'll briefly review some resource management techniques -
by resource I'm using memory as my main example, but there are
other examples such as open files; by "management", i mean
keeping track of how that resource is allocated, used and released.

2.1 There's an explicit, C-like, style.

(see slide)
We allocate some memory (for example, with malloc). We use it
(I don't care how, for the purposes of this talk).
We free it. Here I'm using r to mean a "reference" or a "pointer"
without getting too technical about what one of those is.

Or we open a file, write to it, and close it - the reference there
is the file handle.

In these two examples, that happens all in a row in the source code,
so it's quite easy to reason about.

The third example has a helper
function withFile which also helps with reasoning: the handle is valid
only inside the supplied action block.

In reality it is likely a reference gets passed around
stored and used in several different places,
on its eventual journey to being released.

(As a side note, C is pretty liberal about what you can
use that memory for - you can allocate a number of bytes without
really telling the compiler what you're going to use those bytes
for.)

The correctness proof happens "in our head (or test suites etc)",
not in the compiler.

</aside>
</section>

<section>
<h2>use-after-free</h2>

<pre><code class="C" data-trim data-noescape>
void f() {
  r = malloc(10);
  free(r);
  mutate(r);
}
</code></pre>

<pre><code class="haskell" data-trim data-noescape>
do
  r <- hOpenFile "foo" WriteMode
  hClose r 
  hPutStrLn r "hello world"
</code></pre>

<aside class="notes">
What might go wrong?

We might free the resource before we have finished using it. Then what
happens? Memory corruption or a segfault or other failures.
[use-after-free]
</aside>

</section>

<section>
<h2>resource leak</h2>
<pre><code class="C" data-trim data-noescape>
void f() {
  r = malloc(10);
  mutate(r);
}
</code></pre>

<pre><code class="haskell" data-trim data-noescape>
do
  r <- hOpenFile "foo" WriteMode
  hPutStrLn r "hello world"
</code></pre>

<aside class="notes">

We might forget to free the memory, and then we have a memory leak:
that memory remains allocated "forever" (for some notion of forever)

</aside>

</section>

<section>

<pre><code class="haskell" data-trim data-noescape>
let r = FooConstructor
    in process r
</code></pre>

<aside class="notes">
2.2 Another style of resource management is to use garbage collection.

This has been round since the 1950s, though I first really used this in
Java. It's pretty much the standard approach for memory
management in high level
languages - for example, it is how Haskell does things - but not other
stuff like file handle management.

So how does this work?
We allocate some memory. We use it. We just stop talking about it
and it goes away. Eventually.

An advantage here is that if 'r' is in scope,
we know the memory will not have been released.

We can't name a thing, unless that thing is valid: knowing the "name"
of the thing keeps it valid.

A disadvantage is that garbage collectors run at runtime - this adds on
a bunch of runtime overhead. Namecheck pusher/will for their
especially degenerate garbage collection situation they encountered.

Another disadvantage is that sometimes we do want to be a
bit more explicit about when 
a resource is released - we want to know a file has been closed,
perhaps - but with garbage collection, you have to "hope" that you
really have got rid of all references and that the collector runs
"in time".

By "hope" I mean manually prove outside of the type system.
</aside>

</section>

<section>
<pre>
--

TODO: a third way:
local variables

[SLIDE]
f()
{
  int x;
  mutate(&x)
} // implicit free of x at end of scope

We don't write a free call, and x will always be released, but we
need to be careful to not pass a reference to x outside of the
scope (for example, if mutate stores it in a global struct for
later use) - else same "use-after-free" bug

[SLIDE]
f() 
{ int x;
  return &a;
}

We don't have this static-scope risk in GC languages.

In languages like C and Java, this are heavily restricted to a
certain set of data types - for example, to simple data types
like integers (or only references to more complex structures).
We can't use this technique to allocate a linked list, for example.

====

3.  So what does Rust do?

3.1 Well, none of those.

it lets us write code like this:

SLIDE: TODO: use rust syntax
r = new Foo() 
mutate(r)
// drop(r)

like the garbage collector or local variable case;

... r can be a complex structure

... but with memory release somehow managed
statically - at compile time (like the local variable case)

... but we can pass a pointer to that memory around outside of 
the local scope (like the garbage collected case).

Rust puts in release calls (called Drop) at the right place.

This isn't magic though, and if we squish down complication in one
place, it pops up in another. I'm going to talk about that complication
in the rest of this talk.


3.2

Let's take a slightly more theoretical look at things that you can do with 
a pointer or a reference (or a handle...) and how that might go
wrong: - actually, these are things you can do to any value in a
language, but the problems happen when those values are reference to
some other reasource.


3.2.1 Forgetting

We can forget a reference - we might just stop mentioning it,
or we might only talk about part of a structure such as a tuple.

SLIDE: todo in rust
or TODO in haskell
f r = 7

f (r,s) = r -- forget s
f (r,_) = r

We had a pointer to r. But we've abandoned it without releasing
the memory. In a garbage collected system, that means the
garbage collector can come along later to release it.

3.2.2 ...

In a non-garbage collected system, often that's OK too,
because we can also duplicate references and free the reference
through that duplication.

SLIDE:
f(r) = 7

r = alloc()
f(r)
free(r)

We passed r into f, but we also kept a copy ourselves and used it
to free memory.

A non-reference version of this might be

SLIDE: (on end of previous slide?)
sqr(x) = x * x

where we duplicate the number stored in x - that's usually fine to do
in this case.

What if we regard those operations (forgetting, and duplication)
as inherently dangerous, and try to get rid of them?

The only way we can get rid of a pointer is by passing it into free()

SLIDE:
r = alloc()
free(r)

What about if we want to use that memory in a function?

Slide:
r = alloc()
mutate(r)
free(r)

This doesn't work for two reasons:

firstly, mutate() isn't allowed to forget r; and secondly, we can't
pass r to mutate *and* keep a copy for later use.

So mutate() could free r itself, but that's a bit limiting. Another
thing it could do is pass it back:

r = alloc()
r' = mutate(r)
free(r')

mutate(r) = 
   ...
   return r


We end up with explicit threading of the reference through the code.

Then, we can use syntax to hide that, and
get back this: (todo: rust & syntax for passing references - borrowing)

r = alloc()
mutate(r)
free(r)

which looks the same syntactically as our earlier example but now has
linear semantics. We can say that mutate has "borrowed" the value
and given it back afterwards.

Another bit of syntax we can do: instead of needing to expliclty
free r, we can insert a free call implicitly, when r goes out of
scope.

r = alloc()
mutate(r)

Syntactically this looks like the garbage collected case -
but it isn't: we have those linear semantics that means we know r is still
allocated at the end of this code block and that it's going to
go out of scope at the end of this code block and that it has not
been duplicated anywhere; so we can and must release it at the
end of the block. releasing it like a stack automatic, even though
there might be a lot more than just a couple of bytes on the stack.

NOTES:

0. about rust (1 min)

1. Rust details (11 mins)

    - motivation: basic motivation: freeing memory.
         C - explicit frees. reasoning in programmers head.

           - code sample. code sample with double free, or free then re-use. or we might forget to free it at all. memory leak in the sense of "the allocator knows it is allocated, but nobody else does"

         many more recent languages (Java/Python/Haskell/Python...) - garbage collection. expensive. "naive" - as a programmer I know that some data won't be freed "now", but GC still has to make a *runtime* check of all that. Lots of GC tech over the years. It's "impossible" to have a pointer to memory that isn't allocated (and we usually call these references now, not pointers)

           - code sample: allocate. long process, but keep variable assigned. so doesn't get freed. every gc in long process needs to consider this allocation. memory leak in the sense of "we don't need it, but the GC won't release it because we have a variable pointing at it".

       - what if we could have the efficiency of static checking, with
         the safety of GC?
       - rust attempts to give some of this, though of course as you whack the mole down in one place, it pops up somewhere else, as we'll see...

  ownership

  lack of explicit frees - the frees go where the owner drops
   the value

  borrowing so you don't have to pass things back
    - fighting the borrow checker. aka fighting the type checker.

  type signatures - and how they are reminiscent of crazy haskell
    type signatures  (eg lens, eff, servant)

  analogies to compile-time/static garbage collection

  various wrappers for ownership fun (reference counting - with
    standard rc problems)

  passing between threads?
   - somewhat overblown chapter title "Fearless Concurrency" - specifically relevance to memory safety
   - closures - passing ownership into a closure. 'move' keyword (not just for thread stuff... but useful when launching a thread). 'Copy' trait - for things that look like "values" - got rid of duplication but this is how we allow it. talking about "ownership" that is not just hierarchical scopes. channels - sending down a channel changes ownership - no longer in local scope, so we don't (and can't) use a thing or free it. message passing - but without copying.

(concurrent) rust exmaples that are neat:

  example of interesting ownership transfer:
  1. todo: a simple transfer of ownership (into a function? or a struct?)

  2. channel concurrency - sending memory to someone else is, like a free,
    a way of safely getting rid of our responsibility for a resource,
    and also means we can't access it any more.

  mutux-on-memory (in shared memory concurrency section) - uses a smart pointer
   the is aquired by unlocking, and when you drop the smart pointer,
   it re-locks the mutex. mention that you would use unsafe to do this,
   which, like in haskell, declares that you believe it to be safe
   but the compiler can't check so. 'Drop' trait. Combines a value
   which proves that we have access to the locked meory with the
   actual reference to the memory, into a single smart pointer.
   We can only ever have one of these smart pointers in existence at
   once (if mutex is correctly implemented)

 - introduce "smart pointers" before that? as a pointer that can 
    know how its going to be used - mutex as a particular instance
    of that - or perhaps just mutex as *the* example to introduce
    this?
   - because we're more restricted on what we can do with pointers
     /references, we can have (need?) more rust libraries that express
      reference/pointer patterns in rust code,
     that previously existed in our head or in the garbage collector.
    - reference counting smart pointers, mutex above.
      - eg 1. reference counting smart pointer: the pointer owns
         the memory, and keeps track of how many people have a copy,
         (because it has code both to create and drop references),
         and can release memory on 0 references.
      - more interestingly, mutex, for concurrency.


2. what does haskell offer? (7 mins)
- and can point out arnaud in the pub afterwards
 2.1 state monads: (2 min)
    state actions are compoletely serialised even when operating on
    "different" pieces of state (you can name them differently as STRef
    but actions are still explicitly serialised). pretty lame.
    we have (ST s) with an uninstantiated s, to stop us passing
    out a reference to code in a different sequence, or to pure code.
  - something to do with if we want a thing to do linear operations
     on, we can't let it be a pure "value" any more - for example,
     mutable in place array operations? (I think there's an array
     for that - MArray) - linearisation of all array operations by
     monad sequence. - code examples of MArray? - there's an example
     in s2.2 of the linear types paper, even.
 2.2 linear types - tweag proposal (5 min)
    very brief overview
    - similar direction but different: can do more, and less.
      eg rust has sugar - for borrowing (pass a value in and
      get it back, and it is in a particular state inside the
      borrowed call), and for implicitly releasing a value.
    - maybe overview of interesting haskell-specific issues based
        on section titles in paper - eg "consuming" a value in a lazy
          language; using higher order functions; ... and some of the case studies. perhaps just put those on a slide and mention them in hardly any depth?

====
aspiwack [17:42]
Full instructions here: https://github.com/tweag/ghc/tree/linear-types#readme

benc [17:42]
just so i can say in the talk "i have compiled something fairly simple with it" rather than "i have heard about this thing"
aspiwack [17:42]
A library with a fully configured stack.yaml: https://github.com/tweag/linear-base/
====

3. overview slide (1 min)


really care about counting references at compile time:
 given a reference R, do we: drop it, duplicate it, neither (in which case, I think, it is linear?)


rust notion of lifetimes and ownership - these can be awkward to reason about. compile time type variables...


copy trait: can mark that it is meanigful to just copy the bits to
 duplicate a value.
 - for example a double-length integer would make sense, but a
   file handle not so.
 - so this is not really about the "size" of the data, but of who
   is managing any other resources that are references by the
   bitwise value.
  
clone trait: let's the type handle how to duplicate itself, and is
 invoked as an explicit operation.
 

</pre>
</section>
                        </div>
                </div>
                <script src="head.js"></script>
                <script src="reveal.js/js/reveal.js"></script>
                <script>
                        Reveal.initialize({
  transition: "none",
  slideNumber: "c/t",
  dependencies: [
{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                { src: 'reveal.js/plugin/notes/notes.js', async: true },
                { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

                ]
                        });
                </script>
        </body>
</html>


